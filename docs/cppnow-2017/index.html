<!doctype html>

<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Towards Painless Testing</title>

		<meta name="description" content="Towards Painless Testing">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">

            <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">
#### C++ Now 2017
# Towards Painless Testing

Kris Jusiak, Quantlab Financial

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

## "The only way to go fast is to go well" Uncle Bob

==============================================================================

## Agenda

* Testing
  * Why?
  * How And When?
    * Frameworks
    * Mocking
    * Writing A Testable Code (Unit Testing)
        * Single Responsibility Principle
        * Dependency Injection
    * Automatic Mocks Injection
    * Acceptance Testing
* Showcase (User Story -> ... -> Commit)
* C++2X...

==============================================================================

##Why we need to test?

![testing](images/cowboy.png)

----

##It's all about Money!

![cost](images/cost.jpg)

----

##Different types of tests have different costs

![pyramid](images/pyramid.png)

----

* Unit-Tests - 70-85% 
  * Testing in isolation (mocking)
  * Easy to write
  * Quick to run (immediate feedback)
  * Find code issues quickly 
  * Test corner cases
  * Documentation (requirements)
  * Refactoring without worries

* Integration-Tests - 10-20% (between classes)
  * Integration between classes

* Acceptance-Tests - 5-10%
  * Slower to run
  * Harder to write
  * In some cases might be manual

----

##Test your code and save more money!

![cost_testing](images/cost_testing.jpg)

----

### "Don't cling to a mistake just because you spent a lot of time and money making it!"

==============================================================================

### Testing - Goals

* Testing can't be hard (simplicity)
* Tests should not require tests for tests (declartivness)
* Implementation details should not affect tests (reusability)
* Testing code should be as good as production code (quality)

> To achieve those goals we need...

==============================================================================

### 1. We need a good* testing framework

```cpp
#include <cassert> // no much testing facilities in the standard

void test_should_add_2_numbers() {
  assert(4 == add(2, 2)); // *no proper asserts
                          // *no nice outputs
}

int main() {
  test_should_add_2_numbers(); // *no automatic test registration
}
```

```sh
$CXX -g tests.cpp && ./a.out # *no way to specify which tests to run
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">Boost.Test</p>

```cpp
BOOST_AUTO_TEST_CASE(should_add_2_numbers) {
  BOOST_CHECK_EQUAL(4, add(2, 2));
}
```

#### <p align="left">Catch</p>

```cpp
TEST_CASE("Numbers can be added", "[add]") {
  SECTION("should add 2 numbers") { REQUIRE(4 == add(2, 2)); }
}
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">GoogleTest</p>

```cpp
TEST(AddTest, should_add_2_numbers) {
  EXPECT_EQ(4, add(2, 2));
}
```

#### <p align="left">GoogleTest/GUnit.GTest</p>

```cpp
GTEST("Can add numbers") {
  SHOULD("add 2 numbers") { EXPECT_EQ(4, add(2, 2)); }
}
```

#### <p align="left">GUnit.GTest-Lite (it will be used on the slides)</p>
```cpp
"should add 2 numbers"_test = [] {
  EXPECT(4 == add(2, 2));
};
```

----

### Test-Frameworks references

| | |
|-|-|
| GUnit.GTest | https://github.com/cpp-testing/GUnit#GTest |
| GUnit.GTest-Lite | https://github.com/cpp-testing/GUnit#GTest-Lite |


==============================================================================

## 2. We need a good* Mocking framework

####good*
* Easy to use
* Limited boilerplate (especially macros)
* Mocking Interfaces/Concepts/Type-Erasure

----

### Stubs vs Fakes vs Mocks

| | |
|-|-|
|Fake|An object with limited capabilities|
|Stubs|An object that provides predefined answers to method calls and record calls|
|Mocks|An object on which you set expectations which are verified by the mock|

---

https://martinfowler.com/articles/mocksArentStubs.html

----

###Mocking interfaces - the story so far - GoogleMock

```cpp
class IReader {
public:
  virtual ~interface() = default;
  virtual int read() const;
};
```

```cpp
/**
 * Boilerplate
 */
class MockReader : public IReader {
public:
  MOCK_CONST_METHOD1(read, int()); // See the bug?
};
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  EXPECT_CALL(reader, read()).WillOnce(Return(42));
  EXPECT(42 == reader.read(42));
};
```

----

###Mocking interfaces - better alternatives

* HippoMocks
* FakeIt
* **GUnit.GMock** (based on GoogleMock)

```cpp
"should read 42"_test = [] {
  GMock<IReader> reader{};
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

* No hand written macros :)
* No boilerplate code
* Not a standard solution either!
  * vtable manipulation involved

----

### Mocking templates

#### We are back to square one <- macros

```cpp
template<class TReader>
auto read(TReader& reader) { return reader.read(); }
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  // At least we can use the same front-end
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  read(reader);
  EXPECT(42 == reader.read);
};
```

----

### Mocking concepts

#### Concepts lite - not yet :(

```cpp
template <class T>
concept bool Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  requires(T t) {
    { t.read() -> int }
  }
};
```

#### But with concept emulation - yes, please!

```cpp
template <class T>
constexpr auto Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  Callable<int(T::*)>($(read));
```

----

### Mocking concepts

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

## TODO explain how!

----

### Mocking type-erasure

##### Type Erasure (dynamic dispatch without inheritance)
```cpp
any<Readable> reader = FileReader{"file.txt"};
reader = StreamReader{};
```

```cpp
auto read(any<Readable> reader) {
  return reader.read();
}
```

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based
                            // the same as with concepts!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

### Mocking references

| | |
|-|-|
| GoogleMock | https://github.com/google/googletest |
| GUnit.GMock | https://github.com/cpp-testing/GUnit#GMock |
| Dyno (Type-Erasure) | https://github.com/ldionne/dyno |

==============================================================================

## 3. We need to write a testable/'SOLID' code 

----

##Story: Print a value from a file

```
Scenario 1: Value from a file is displayed
 Given an 'input.txt' file with an integer value in it
   And console terminal is ready
 When the App runs
 Then the integer value from 'input.txt' file
   should be printed on the terminal console
```

----

## KISS - ~~Keep it simple~~, STUPID

```cpp
int main() {
  auto value = 0;
  {
    std::ifstream file{"input.txt"};
    assert(file.good());
    file >> value;
  }
  std::cout << value << '\n';
}
```

----

## Let's try to test it

####It suppose to be easy!

1. Unit-Tests - **Give me a break!**

2. Acceptance-Tests
  * Create a file and print a text into it?
  * Redirect std::cout to some other file?
  * Compare files?
  * I give up, it's too difcult, it seems to WORK, I checked it manually!
    * What about your future team members?

3. Manual-Tests by some other team - **Yes, please!**

----

###Solution -> Start form the test first!

==============================================================================

## 3.1. We need to test drive the code - Test Driven Development (the when)

> Unit Tests (the what)

----

##TDD Mantra - Red-Green-Refactor

<img src="images/tdd.gif" width="40%" />

> Refactor => remove duplicates!

----

##The Three Rules Of Tdd

1. You are not allowed to write any production code unless it is to make a failing unit test pass
2. You are not allowed to write any more of a unit test than is sufficient to fail
  * Compilation failures are failures
3. You are not allowed to write any more production code than is sufficient to pass the one failing unit test

----

##Let's start all over again with TDD

----

#### 1. TDD/RED - Write a bit of test (start from expectations, intentions)

```cpp
"should not print anything when the input is empty" = [] {
  app.run();
  EXPECT("" == out.str());
};
```

----

#### 2. TDD/GREEN - Make it compile/pass (the simpler way)

```cpp
"should not print anythinig when the input is empty" = [] {
  std::stringstream out{};
  struct {
    void run() { }
    std::ostream& os;
  } app{out};
  app.run();
  EXPECT("" == out.str());
};
```

----

#### 3. TDD/REFECTOR - Remove duplicates/extract

```cpp
class App {
public:
  explicit App(std::ostream& os)
    : os(os)
  { }

  void run() { }

private:
  std::ostream& os;
};
```

```cpp
"should not print anythinig when the input is empty" = [] {
  // given (arrange)
  std::stringstream out{};
  App app{};

  // when (act)
  app.run();

  // then (assert)
  EXPECT("" == out.str());
};
```

----

#### 1. TDD/RED - Write a bit of the next test

```cpp
"should print value 42 when the input is 42" = [] {
  // given
  std::stringstream out{};
  std::stringstream in{};

  // when
  app.run();

  // then
  EXPECT("42" == out.str());
};
```

----

#### 2. TDD/GREEN - Make it compile/pass (the simpler way)

```cpp
"should print value 42 when the input is 42" = [] {
  // given
  std::stringstream in{}, out{};
  struct { 
    void run() { out << "42"; }
    std::ostream& out;
    std::istream& in;
  } app{in, out};
  
  // when
  app.run();
  
  // then
  EXPECT("42" == out.str());
};
```

----

#### 3. TDD/REFECTOR - remove duplicates (across all tests)

```cpp
"should not print anythinig when the input is empty" = [] {
  // given (arrange)
  std::stringstream in{}, out{};
  App app{in, out};

  // when (act)
  app.run();

  // then (assert)
  EXPECT("" == out.str());
};
```

```cpp
"should print value 42 when the input is 42" = [] {
  // given (arrange)
  const auto value = "42";
  std::stringstream in, out{};
  App app{in, out};
  in << value;

  // when (act)
  app.run();

  // then (assert)
  EXPECT(value == out.str());
};
```

----

#### 3. TDD/REFECTOR - remove duplicates (across the implementation)

```cpp
class App {
public:
  App(std::istream& in, std::oustream& out)
    : in(in), out(out)
  { }

  void run() { out << in.rdbuf(); }

private:
  std::istream& in;
  std::ostream& out;
};
```

----

##Test Driven Development (TDD)

* All benefits of Unit-Testing!

* TDD drives the design by producing
  * Loosely coupled code
  * Easy to test code

* No need for the test coverage <- it implies 100%

==============================================================================

###3.2. We need to write `SOLID` instead of `STUPID` code

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td>Singleton</td></tr>
    <tr><td><b>T</b></td><td>Tight Coupling</td></tr>
    <tr><td><b>U</b></td><td>Untestability</td></tr>
    <tr><td><b>P</b></td><td>Premature Optimization</td></tr>
    <tr><td><b>I</b></td><td>Indescriptive Naming</td></tr>
    <tr><td><b>D</b></td><td>Duplication</td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><u>Single Responsibility</u></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><u>Dependency inversion</u></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code" Uncle Bob

----

#### God object
```cpp
class Manager {
public:
  int read() const;
  void write(int);
  void open(std::string_view);
  void update(float);
  bool send(std::any);
  std::any get();
  ...
};
```

###Single responsibility principle

> "A class should have only one reason to change" Uncle Bob

----

###Single responsibility principle

```cpp
/**
 * Purpose: read (more generic istream)
 */
class Reader {
public: 
  int read(); 
};
```

```cpp
/**
 * Purpose: print (more generic ostream)
 */
class Printer {
public: 
  void print(int); 
};
```

----

###Single responsibility principle is needed but it's not enough for testable code!

```cpp
class App {
 Reader reader; // tightly coupling, no way to fake it for the test
 Printer printer; // tightly coupling, no way to fake it for the test

public:
  void run();
};
```

> Code like that would never be written using TDD!

----

##We need more, we need to be able to inject fake implementations!

##We need...

----

###The Dependency Inversion Principle	

> "Don't call us, we'll call you", Hollywood principle

```cpp
// It's all about the construction
App::App(std::istream& in, std::ostream& out); // DEPENDENCY INJECTION!
```

----

###The Dependency Inversion Principle	

> "Depend on abstractions, not on concretions"

####What can we inject?

| | |
|-|-|
| Compile-Time | Templates/Concepts |
| Run-Time | Interfaces/Type-Erasure/Functions |

----

##Let's get back to our example

----

##Test - goal - sudo syntax

```cpp
"should print read text"_test = {
  // given
  [app, fakes] = make<App>(); // create an app and fakes for me, please

  // when
  fakes<Reader>.read().return(42);
  fakes<Printer>.print(42);

  // then
  app.run();
}
```

* Write test easily and quickly
* Implantation details, how deps are injected, should not affect the test
* Isolate the word around us

----

###Templates / Policy Design / Duck Typing

```cpp
template<class TReader, class TPrinter>
class App {
  TReader reader;
  TPrinter printer;

public:
  App(TReader reader, TPrinter printer)
    : reader(reader), printer(printer)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

```cpp
int main() {
  Reader reader{};           // wiring
  Printer printer{};         // wiring
  App app{reader, printer};  // wiring
  app.run();
}
```

----

###Composition Root

> Unique location in an application where modules are composed together

```cpp
int main() {
  App{...}.run();
}
```

####Simplifies writing integration tests

----

###Concepts/C++2X?

```cpp
template <class T>
concept bool Readable = requires(T reader) {
  { reader.read() } -> int;
};
```

```cpp
template <class T>
concept bool Printable = requires(T printer) {
  { printer.print() } -> void;
};
```

----

###Concepts/C++2X?

```cpp
template<Readable TReader, Printable TPrinter> // concepts
class App {
  Readable reader;
  Printable printer;

public:
  // Same as template<Readable, Printable>
  App(Readable reader, Printable printer)
    : reader(reader), printer(printer) {}

  void run() {
    printer.print(reader.read());
  }
};
```

```cpp
int main() {
  Readable reader = FileReader{"input.txt"}; // wiring
  Printable printer = ConsolePrinter();      // wiring
  App{reader, printer}.run();                // wiring
}
```

----

###Virtual functions/interfaces (V4)

```cpp
class IReader {
public:
  virtual ~IReader() noexcept = default;
  virtual int read() = 0;
};
```

```cpp
class FileReader final : public IReader {
  std::istream& input;

public:
  explicit FileReader(std::istream&);
  void read() override;
};
```

----

###Virtual functions/interfaces (V4)

```cpp
class IPrinter {
public:
  virtual ~IPrinter() noexcept = default;
  virtual void print(int) = 0;
};
```

```cpp
class ConsolePrinter final : public IPrinter {
  std::ostream& output;

public:
  explicit ConsolePrinter(std::ostream&);
  void print(int) override;
};
```

----

###Virtual functions/interfaces (V4)

```cpp
class App {
  IReader& reader;
  IPrinter& printer;

public:
  App(IReader& reader, IPrinter& printer)
    : reader(reader), printer(printer) {}

  void run() {
    printer.print(reader.read());
  }
};
```

```cpp
int main() {
  auto file = std::fstream{"input.txt"}; // wiring!
  auto reader = FileReader{file};        // wiring!
  auto& out = std::cout;                 // wiring!
  auto printer = ConsolePrinter{out};    // wiring!
  App{reader, printer}.run();            // wiring!
}
```

----

###Virtual functions/interfaces - performance
####final keyword and devirtualization

![final](images/final.png)
https://godbolt.org/g/e8olYN

----

###Virtual functions/interfaces - inheritance

> "Inheritance Is The Base Class of Evil" Sean Parent

-

https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil

----

###Type erasure/Virtual Concepts/C++2X (V6)

```cpp
class App {
  virtual Readable reader; // type erasure (concept from V3)
  virtual Printable printer; // type erasure (concept from V3)

public:
  // Same as template<Readable, Printable>
  App(Readable reader, Printable printer)
    : reader(reader), printer(printer)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

```cpp
int main() {
  Readable reader = FileReader{"input.txt"}; // wiring
  Printable printer = ConsolePrinter();      // wiring
  App{reader, printer}.run();                // wiring
}
```

----

* STL example: `std::shared_ptr deleter`
* [(SG8) Virtual concepts](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf)

----

###Law of Demeter

> "Only talk to your immediate friends"

----

###Doesn't matter which option will be chosen the wiring will have to happen either way!

----

Dependency Injection

###Manual DI - Wiring

* ####Single Responsibility Principle
  =>
    * ####A lot of classes
    =>
      * ####Wiring Mess
      =>
        * ####Hard to maintain + Lazy programmers (99%)
        =>
          * ####Hacks/Workarounds (~~Single Responsibility~~)

-----

###Solution

####Simplify/Remove the wiring mess
  ####By Automating dependency injection?
=>
### [[Boost].DI](https://github.com/boost-experimental/di)

==============================================================================

###[[Boost].DI](https://github.com/boost-experimental/di)

* One header - 3k LOC - (boost/di.hpp) / generated
* Neither Boost nor STL is required
* No 'if's, 'virtual's, 'exception's (-fno-rtti, -fno-exceptions)
* Non-intrusive (constructor/templates parameters deduction)
* Compile-time creation guarantee (no run-time errors)
* Supported compilers (C++14)
  * [Clang-3.4+](https://travis-ci.org/boost-experimental/di), [XCode-6.1+](https://travis-ci.org/boost-experimental/di), [GCC-5.2+](https://travis-ci.org/boost-experimental/di), [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

> [Boost].DI is not an official Boost library, yet!

----

###[[Boost].DI](https://github.com/boost-experimental/di) - API

####Injector
```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  explicit injector(TDeps&&...) noexcept;
  injector(injector&&) = default;
  injector& operator=(injector&&) = default;

  template<class T> requires creatable<T>()
  constexpr T create() const;
};
```

```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
constexpr auto make_injector(TDeps&&...) noexcept;
```

####Bind
```cpp
template<class... Interfaces>
  requires is_convertible<Interfaces..., Implementation>()
di::bind<Interfaces...>.to<Implementation>()
                       .to(Implementation&& value)
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Hello World

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
template<class TReader = class Readable>
class App {
 public:
  App(TReader&, const IPrinter&); // DI handles
};        ^                 ^     // order and types
          |                 \-------------------------\
          \---------------------------------------\   |
int main() {                                      |   |
  const auto injector = di::make_injector(        |   |
     di::bind<class Readable>.to<FileReader>(), --/   |
     di::bind<IPrinter>.to<ConsolePrinter>() ---------/
  );

  injector.create<std::unique_ptr<App>>()->run();
}
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Performance

```sh
time $CXX -std=c++14 app.cpp # 0.092s
```

#####ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

#####Same as

```cpp
return make_unique<App>(...);
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Benchmarks (GCC-7/Java8)

| 64 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.376s       |  0.570s            | 1.411s        |
| Execution time      | 0.002s       |  0.528s            | 0.157s        |

---

| 256 types, 1-4 ctor params, 1024 iterations | **[Boost].DI** | **Guice** | **Dagger2** |
| --------------------- | ------------ | ---------------- | ------------- |
| Compilation time    | 0.706s       | 0.642s             | 1.903s        |
| Execution time      | 0.002s       | 0.544s             | 0.210s        |

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Compile-time errors

```cpp
const auto injector = di::make_injector(
// di::bind<IPrinter>.to<ConsolePrinter>(), // missing wiring
   di::bind<class Readable>.to<FileReader>()
);
auto app = injector.create<App>();
```

#####Full Compilation-Time Error Message

```cpp
error: 'create<App>' is deprecated: creatable constraint
  injector.create<App>();           not satisfied
           ^
note 'create<App>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<IPrinter>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----



==============================================================================

###[[Boost].DI](https://github.com/boost-experimental/di) - Behaviour Driven Development (BDD)

####Acceptance Tests

```cpp
"Given an input file
 When App is running
 Then value from input file should be printed"_test = [] {
  mocks_t mocks;
  {
    std::ofstream file{"input.txt"};
    file << 42;
  }
  const auto injector = di::make_injector(
    config(), // production wiring
    di::bind<IPrinter>.to(GMock<IPrinter>(mocks)) [di::override]
  );

  EXPECT_CALL(mocks<IPrinter>(), print(42));
  injector.create<App>().run();
};
```

----

##The story so far - Virtual functions/interfaces

>[[Boost].DI](https://github.com/boost-experimental/di)
```
Automatic constructor injection
```

> [GUnit.GMock](https://github.com/cpp-testing/GUnit)
```
Easy mocking
```
```
Automatic mocking injection
```

----

##Concepts driven design with [[Boost].DI](https://github.com/boost-experimental/di)

###Idea

* Concepts checking (type constraints for templates)
    * no more horrible error messages
* Type erasure based on concepts (dynamic dispatch)
    * 100% value semantics (no heap)
* Mocking (automatic generation from concepts)
    * Goal - write tests once, it shouldn't matter what and how is injected

----

##Concepts driven design / C++14

####API (much more powerful than interfaces)
```cpp
const auto Concept = $requires(args...)(
  expressions...
);
```

####Example
```cpp
const auto Fooable =
  $requires(auto&& t, std::ostream& os) (
    T(t), // copy constructible
    os << t // printable
  ) &&
  $(foo)<void(int, double)>();
```

http://ericniebler.com/2013/11/23/concept-checking-in-c11/

----

##Concepts driven design / C++14 (V7)

>Short `decltype` notation
```cpp
#define $ decltype
```

>Alternative
```cpp
using Concept_t = decltype(Concept);
```

----

##Concepts driven design / C++14

####Concept checking (used when wiring)
```cpp
static_assert(requiers<Foo>(Fooable), "");
static_assert(requires<Bar>(Fooable), "bar requires to be Fooable!");
```

####Concepts mocking
```cpp
GMock<$(Fooable)> mock;
EXPECT_CALL(mock, (foo)(42));
mock.read(42);
```

####Type erasure
```cpp
any<$(Fooable)> foo = Foo{}; // holds anything
foo.foo(42, 77.0);           // Fooable (stack!)
```

####Type erasure mocking
```cpp
any<$(Fooable)> foo = GMock<$(Fooable)>();
EXPECT_CALL(mock, (foo)(42, 77.0));
foo.foo(42, 77.0);
```

----

##Concepts driven design / C++14 (V7)

```cpp
const auto Readable =
  $requires(auto&& t, std::ostream& os) (
    T(t),    // copy constructible
    os << t  // printable
  ) &&
  $(read)<int()>();
```

```cpp
const auto Printable =
  $requires(auto&& t, std::ostream& os) (
    T(t),    // copy constructible
    os << t  // printable
  ) &&
  $(print)<void(int)>();
```

----

##Concepts driven design / C++14 (V7)

```cpp
template<class TReader  = $(Readable)   // TReader  = 'Concept'
       , class TPrinter = $(Printable)> // TPrinter = 'Concept'
class App {
  TReader reader;
  TPrinter printer;

public:
  App(TReader reader, TPrinter printer)
    : reader(reader), printer(printer)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

```cpp
int main() {
  const auto injector = di::make_injector(
    di::bind<$(Readable)>.to<FileReader>(),
    di::bind<$(Printable)>.to<ConsolePrinter>()
  );

  injector.create<App>().run();
}
```

----

##Concepts driven design / C++14 (V7)

* (+) We can test it in isolation
* (+) Short error messages (type constraints verification)
* (+) Automatic mocks generation (GMock)
* (+) Dynamic dispatch via type erasure supported out of the box
* (+) Reader/Printer are not tightly coupled to the App
* (+) Different Readers/Printers can be injected
* (-) Header files only

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Concepts driven design - Compile-time errors

```cpp
const auto injector = di::make_injector(
  di::bind<$(Readable)>.to<Logger>(), // Logger isn't Readable!
  di::bind<$(Printable)>.to<ConsolePrinter>()
);
```

#####Full Compilation-Time Error Message

```cpp
di.hpp: error: static_assert failed "constraint not satisfied"

di.hpp: note: in instantiation of template class
  'concept_check<Readable>::is_not_satisfied_by<Logger>'

app.cpp:: note: while substituting template 'to'
  di::bind<Readable>.to<Logger>()

app.cpp: error: 'class Logger' has no member named 'read'
```

----

###Concepts driven design - Easy/Automatic Mocking

####[GUnit.GMock](https://github.com/cpp-testing/GUnit)
```cpp
GMock<$(Readable)> readableMock;
EXPECT_CALL(readableMock, read(_)).WillOnce(Return(42));
```

####Test (same as with interfaces)
```cpp
"should print read text"_test = [] {
  constexpr auto value = 42;

  auto [sut, mocks] = make<App>(); // creates System Under Test
                                   // and mocks

  InSequence sequence;
  EXPECT_CALL(mocks<$(Readable)>(), read()).WillOnce(Return(value));
  EXPECT_CALL(mocks<$(Printable)>(), print(value));

  sut.run();
};
```

----

###Concepts driven design - switching to run-time - type erasure

```cpp
template<class TReader = $(Readable)>
class App {
  TReader reader;
  any<$(Printable)> printer; // type erasure based on concepts

public:
  App(TReader reader, any<$(Printable)> printer)
    : reader(reader), printer(printer)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

* ####Wiring - NO CHANGES REQUIRED
* ####Test - NO CHANGES REQUIRED ([GUnit.GMock](https://github.com/cpp-testing/GUnit))

----

###Concepts driven design - switching to run-time - type erasure

####Implementing features by wiring

```
Scenario 2: Value from an input file is displayed on the QtWindow
 Given an 'input.txt' file with an integer value in it
   And the first command line argument equals to "QtPrinter"
 When the App runs
 Then the integer value from 'input.txt' should
      be printed on the QtWindow
```

----

###Concepts driven design - switching to run-time - type erasure

####Implementing features by wiring

```cpp
const auto config = [](std::string_view printer) {
  return di::make_injector(
     di::bind<$(Readable)>.to<FileReader>(),
     di::bind<$(Printable)>.to([&](const auto& injector) {
       return printer == "QtPrinter"
         ? injector.create<QtPrinter>()
         : injector.create<ConsolePrinter>();
     })
  );
};
```

#####Usage
```cpp
int main(int argc, char** argv) {
  config(argc == 2 ? argv[1] : nullptr).create<App>().run();
}
```

----

###Concepts driven design together with interfaces

```cpp
template<class TSynchronizer = $(Synchronizable)>
class FileReader final {
public:
  FileReader(std::string_view path
           , const std::shared_ptr<ILegacyInterface>&); // virtual
  ...
};
```

```cpp
template<class TWriter = $(Writable)>
class LegacyImplementation final : public ILegacyInterface {
  LegacyImplementation(IFactory* factory      // interface
                     , TWriter writer         // template/concept
                     , any<$(Loggable)> logger); // type erasure
  ...
};
```

----

###Concepts driven design together with interfaces

```cpp
int main() {
  const auto injector = di::make_injector(
    di::bind<$(Readable)>.to<FileReader>(),         // concept -> template class
    di::bind<$(Synchronizable)>.to<Synchronizer>(), // concept -> class
    di::bind<$(Loggable)>.to<Logger>(),             // concept -> type erasure
    di::bind<ILegacyInterface>.
          to<LegacyImplementation>()                // interface -> template class
  );

  injector.create<App>().run();
}
```
<!-- .element: style="margin-left:-3%; width:105%" -->

----

###Concepts driven design with [[Boost].DI](https://github.com/boost-experimental/di)

|  |  |
| ------- | ------------- |
| Try it online! | http://melpon.org/wandbox/permlink/UGaFDy2jaSCeksa1 |


==============================================================================

# Acceptance Test Driven Development (ATDD)

Scenario 1: Value from a file is displayed
 Given an 'input.txt' file with an integer value in it
   And console terminal is ready
 When the App runs
 Then the integer value from 'input.txt'
   should be printed on the terminal console

GTEST(example) {
  namespace di = boost::di;

  SHOULD("create example") {
    const auto injector = di::make_injector(
      di::bind<interface>.to(di::NiceGMock{mocks})
    , di::bind<interface2>.to(di::StrictGMock{mocks})
    );

    sut = testing::make<SUT>(injector);

    EXPECT_CALL(mock<interface>(), (get)(_)).WillOnce(Return(123));
    EXPECT_CALL(mock<interface2>(), (f2)(123));

    sut->update();
  }
}



==============================================================================

# Showcase

----

* Agile (Scrum Methodology)
* UML 2.5 (design)
* eXtreme Programming Techniques
* Continous Integration (github/travis)
* ATDD/BDD/TDD
* C++17

> All code compiles and pass tests.

----

1. Product backlog refinment

Refinment
  Priority: 
    Story:  As a trading system I would like to send orders to the exchange

  Acceptance critera

    Scenario 1: 
      Given an decision engine and a connection to the exchange
      When the decision engine triggers an orders
      And there is no other outstanding order
      Then order should be send to the exchange

    Scenario 2: 
      Given an decision engine and a connection to the exchange
      When the exchange confirmed the order
      Then the confirmation should be sent to the decision engine

    Scenario 3, Scenario 4, ...

Design/Workshop

    Domains
      decision engine <-> gateway <-> exchange

    Cross functional:

           decision engine
          /
         trigger order
         /
        has any oustanding orders
    yes / \ no
     X    gateway
            \ send order
        
           exchange
          /
         confirmation
         /
      gateway
      / send
    decision engine

Tasks
  1. decision... -> yes
  2. decision... -> no
  3. confirmation -> transfer

Planning
  Estimates (poker, has to be understood by everyone)
    * story points <- complexity of the task
      1 sp -> transfer a message trhough all layers

    1. decision... -> yes (2sp)
    2. decision... -> no (1sp)
    3. confirmation -> transfer (3sp)

 team velociy (avg. 20 sp)
 commitment -> 1/2/3

Sprint (1 week)

  Story 1.
    1.1 Acceptance driven development (ATDD with BDD)

      given

      when

      then

      > start from your expectatoins

    Test Driven Development (unit testing)

      TDD mantra
      TDD real values

      should...

      eXtreme programming -> pairing, one test one implementation


      write a bit more of test

    Commit each time 

      * rebase or merge or branch with history how tthe test eveolved

      [Story.1] Add
      
      Problem:
        - fdsalfdlsa

      Solution:
        - fdsalfjdsalfjdlsaj

    Commit content: acceptance test + unit tests + cross functional

    Create a merge request
      github

    Code review
      Did you consider...?


    Someone else is accepting your merge requests

    Take the next story... 
      * Pair with someone else of the team!

As a I would like to 

Artifacts
  * Acceptance criteria (BDD style)

  Scenario 1: Value from a file is displayed
   Given an 'input.txt' file with an integer value in it
     And console terminal is ready
   When the App runs
   Then the integer value from 'input.txt'
     should be printed on the terminal console

  Scenario 1: Value from a file is displayed
   Given an 'input.txt' file with an integer value in it
     And console terminal is ready
   When the App runs
   Then the integer value from 'input.txt'
     should be printed on the terminal console


     NOTE
> Always start from the expections (express intentions!)
Treat code as production code!
* refactor (remove duplicates)


Example (Print read text app)
1. User story
2. Scenarios (BDD style)
3. Design
    o
   / \
  o   o cross-functional tasks
     /
    o

4. Acceptance driven (per task)
 iteration
  * a bit of BDD test
  * a bit of TDD
  * a bit of implementation

Note: eXtreme programming techniques
* pair programming
  * one dev is writing a test, another one is implementing it

5. Commit (cross functional - AT, UT, impl)
6. Merge request / review

goto 4.



==============================================================================

# Testing and C++2X...

----

### Automatic test registration and std::testing assertions

```cpp
"should add 2 numbers"_test = [] {
  std::testing::assert(4 == add(2, 2));
};
```

----

### Test Suites/Fixtures

```cpp
"Calculator"_test_fixture = [] {
  // set-up
  auto sut = calcualtor{};

  "should add 2 numbers"_test = [&] {
    std::testing::assert(4 == sut.add(2, 2));
  };

  "should sub 2 numbers"_test = [&] {
    std::testing::assert(0 == sut.sub(2, 2));
  };

  // tear-down
};
```

----

### Mocking interfaces

```cpp
class ifoo {
public:
  virtual ~ifoo() noexcept = default;
  virtual int bar() = 0;
};
```

```cpp
std::testing::mock<ifoo> foo{};
foo.expect_call(bar).will_once(return(42));
std::testing::assert(42 == foo.bar());
```

### Mocking concepts

```cpp
template <class T>
concept bool IFooable =
  requires(T t) {
    t.bar() -> int
  };
```

```cpp
std::testing::mock<IFooable> foo{};
foo.expect_call(bar).will_once(return(42));
std::testing::assert(42 == foo.bar());
```

----

### Automatic mocks injection

```cpp
"App"_test_fixture = [] {
 constexpr auto value = 42;
 auto [sut, mocks] = std::testing::make<App>();

 mocks.expect_call<Readable>(read()).will_once(return(value));
 mocks.expect_call<Printable>(print(value));

 sut.run();
};
```

----

### STD 
* concepts lite
* virtual concepts
* static reflection
* source line info

==============================================================================

# Summary

----

### "If you liked it then you should have put a test on it" Beyonce rule

----

----

### Good practises are good practices for a reason!

----

### Concepts and static reflection will be a game changer!

----

### Dependency Injection

* A powerful design pattern helping with producing
  * Loosely coupled code
  * Easy to test code (TDD/BDD)

* [[Boost].DI](https://github.com/boost-experimental/di)
  * Removes/Cleanup the wiring mess (boilerplate code)
  * Simplify refactoring (constructor parameters deduction)
  * Make testing easier (automatic mocks injection)
  * Supports templates/concepts injection

==============================================================================

## Questions?

[(SG8) Concepts lite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf) |
[Virtual Concepts](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |
[(SG7) Static reflection](www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf)

| | |
|-|-|
|[Boost].DI | https://github.com/boost-experimental/di |
| VC        | https://github.com/boost-experimental/vc |
| GUnit     | https://github.com/cpp-testing/GUnit |

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
