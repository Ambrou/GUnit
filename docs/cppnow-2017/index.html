<!doctype html>

<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Towards Painless Testing</title>

		<meta name="description" content="Towards Painless Testing">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">
#### C++ Now 2017
# Towards Painless Testing

Kris Jusiak, Quantlab Financial

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

## "The only way to go fast is to go well" Uncle Bob

==============================================================================

## Agenda

* Testing
  * Why?
  * How And When?
    * Frameworks
    * Mocking
    * Writing A Testable Code
        * Single Responsibility Principle
        * Dependency Injection
          * Automatic Mocks Injection
        * Test Driven Development
* Showcase (User Story -> ... -> Commit)
* C++2X...

==============================================================================

##Why testing is important?

![testing](images/cowboy.png)

----

##It's all about Money!

![cost](images/cost.png)

----

##Different types of tests have different costs

![pyramid](images/pyramid.png)

----

* Unit-Tests - 70-85% 
  * Testing in isolation (mocking)
  * Easy to write (graniuality)
  * Quick to run (immediate feedback)
  * Find code issues quickly (regression)
  * Test corner cases
  * Documentation (requirements/specification)
  * Refactoring without worries

* Integration-Tests - 10-20% (between classes)
  * Integration between classes

* Acceptance-Tests - 5-10%
  * Slower to run
  * Harder to write
  * In some cases might be manual

----

##Test your code and save more money!

![cost_testing](images/cost_testing.png)

----

### "Don't cling to a mistake just because you spent a lot of time and money making it!"

==============================================================================

### Testing - Goals

| | |
|-|-|
| Simplicity | Testing can't be hard  |
| Expressiveness | Tests should not have logic |
| Reusability | Implementation details should not trigger tests changes |
| Quality | Test code should be treated as production code |

> To achieve those goals...

==============================================================================

## Consider using a good* testing framework

####good*
* Easy to add and run new tests (automatic test registration)
* Proper assertions system
* Feature reach (test suites/fixtures/different outputs)

----

### Testing in C++ without a framework

```cpp
#include <cassert> // no much testing facilities in the standard

void test_should_add_2_numbers() {
  assert(4 == add(2, 2)); // *no proper asserts
                          // *no nice outputs
}

int main() {
  test_should_add_2_numbers(); // *no automatic test registration
}
```

```sh
$CXX -g tests.cpp && ./a.out # *no way to specify which tests to run
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">Boost.Test</p>

```cpp
BOOST_AUTO_TEST_CASE(should_add_2_numbers) {
  BOOST_CHECK_EQUAL(4, add(2, 2));
}
```

#### <p align="left">Catch</p>

```cpp
TEST_CASE("Numbers can be added", "[add]") {
  SECTION("should add 2 numbers") { REQUIRE(4 == add(2, 2)); }
}
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">GoogleTest</p>

```cpp
TEST(AddTest, should_add_2_numbers) {
  EXPECT_EQ(4, add(2, 2));
}
```

#### <p align="left">GoogleTest/GUnit.GTest</p>

```cpp
GTEST("Can add numbers") {
  SHOULD("add 2 numbers") { EXPECT_EQ(4, add(2, 2)); }
}
```

#### <p align="left">GUnit.GTest-Lite (it will be used on the slides)</p>
```cpp
"should add 2 numbers"_test = [] { // -gnu-string-literal-
  EXPECT(4 == add(2, 2));          // -operator-template
};
```

----

### Testing-Frameworks references

| | |
|-|-|
| GUnit.GTest | https://github.com/cpp-testing/GUnit#GTest |
| GUnit.GTest-Lite | https://github.com/cpp-testing/GUnit#GTest-Lite |

==============================================================================

## Consider using a good* Mocking framework

####good*
* Easy to do to simple things but with possibility to do more complex too
* Limited boilerplate (especially macros)
* Mocking Interfaces/Templates/Concepts/Type-Erasure

----

### Stubs vs Fakes vs Mocks

| | |
|-|-|
|Fake|An object with limited capabilities|
|Stubs|An object that provides predefined answers to method calls and record calls|
|Mocks|An object on which you set expectations which are verified by the mock|

---

https://martinfowler.com/articles/mocksArentStubs.html

----

###Mocking interfaces - the story so far - GoogleMock

```cpp
class IReader {
public:
  virtual ~interface() = default;
  virtual int read() const;
};
```

```cpp
/**
 * Boilerplate
 */
class MockReader : public IReader {
public:
  MOCK_CONST_METHOD1(read, int()); // See the bug?
};
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  EXPECT_CALL(reader, read()).WillOnce(Return(42));
  EXPECT(42 == reader.read(42));
};
```

----

###Mocking interfaces - better alternatives

* HippoMocks
* FakeIt
* **GUnit.GMock** (based on GoogleMock)

```cpp
"should read 42"_test = [] {
  GMock<IReader> reader{};
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

* No hand written macros
* No boilerplate code
* Not a standard solution either!
  * vtable manipulation involved

----

### Mocking templates

#### We are back to square one <- macros

```cpp
template<class TReader>
auto read(TReader& reader) { return reader.read(); }
```

```cpp
class MockReader : public IReader {
public:
  MOCK_CONST_METHOD1(read, int()); // See the bug?
};
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  // At least we can use the same front-end
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  read(reader);
  EXPECT(42 == reader.read);
};
```

----

### Mocking concepts

#### Concepts lite - not yet :(

```cpp
template <class T>
concept bool Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  requires(T t) {
    { t.read() -> int }
  }
};
```

#### But with concept emulation (C++14) - yes!

```cpp
template <class T>
const auto Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  Callable<T, int()>($(read));
```

----

### Mocking concepts

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

### Virtual Concepts - Some insides

```cpp
Callable<T, int()>($(read)) ]--> Constraint
          \_  \_____   \___-> name
            \       \
$(name) [](auto t, auto r, auto... args) { // expression
 struct { // inherit from 
  static auto constraint() {
   return [](const auto &self, decltype(args)... args) 
     -> decltype(self.name(std::forward<decltype(args)>(args)...)) 
   {};
  }
  auto name(decltype(args)... args) {
   return static_cast<decltype(t) *>(this) // static polymorphism
     ->template call<name, typename decltype(r)::type>( // call me...
         std::forward<decltype(args)>(args)...);
  }
 } _; return _; // local struct
}
```

```cpp
template<class... TConstraints>
struct gmock_impl : decltype(std::declval<TConstraints::expression>()(
                             TConstraints::args...))... (
 template <class TName, class R, class... TArgs>
 decltype(auto) call(TArgs &&... args); // calls mocked impl...
};
```

----

### Mocking type-erasure

##### Type Erasure (dynamic dispatch without inheritance)
```cpp
any<Readable> reader = FileReader{"file.txt"};
reader = StreamReader{};
```

```cpp
auto read(any<Readable> reader) {
  return reader.read();
}
```

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based
                            // the same as with concepts!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

### Mocking references

| | |
|-|-|
| GoogleMock | https://github.com/google/googletest |
| Dyno (Type-Erasure) | https://github.com/ldionne/dyno |
| GUnit.GMock | https://github.com/cpp-testing/GUnit#GMock |
<!-- .element: style="margin-left:-13%; width:125%" -->
  * Features
    * No more hand written mocks!
    * Support for more than 10 parameters
    * Support for std::unique_ptr without any tricks
    * Support for overloaded operators
    * Support for mocking classes with constructors
    * 100% Compatible with Google Mocks
    * Quicker compilation times
==============================================================================

### Consider writing `SOLID` instead of `STUPID` code

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td><u>Single Responsibility</u></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><u>Dependency inversion</u></td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><strike>Singleton</strike></td></tr>
    <tr><td><b>T</b></td><td><strike>Tight Coupling</strike></td></tr>
    <tr><td><b>U</b></td><td><strike>Untestability</strike></td></tr>
    <tr><td><b>P</b></td><td><strike>Premature Optimization</strike></td></tr>
    <tr><td><b>I</b></td><td><strike>Indescriptive Naming</strike></td></tr>
    <tr><td><b>D</b></td><td><strike>Duplication</strike></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code" Uncle Bob

----

### Feature: Print a value from a file

### KISS - ~~Keep it simple~~, STUPID

```cpp
int main() {
  auto value = 0;
  {
    std::ifstream file{"input.txt"};
    assert(file.good());
    file >> value;
  }
  std::cout << value << '\n';
}
```

##### Unit-Testing - **Give me a break!**

----

### A few iterations later...

----

#### **Stupid** vs <strike>SOLID</strike>

```cpp
class Manager { // Indescriptive Naming
public:
  Updater& getUpdater(); // Untestability
  Reader& getReader();   // Untestability
  Writer& getWriter();   // Untestability
  Creator& getCreator(); // Untestability
  void update(float);
};
```

```cpp
class App {
public:
  App() { manager = new Manager; } // Tight Coupling
  ~App() { delete manager; }

  __attribute__((always_inline)) void run() { // Premature Optimization
    Logger::instance() // Singleton
      << "run:" << manager.getReader().get()->getValue() << '\n';

    manager.getWriter().getOutputter()->print(
      manager.getReader().get()->getValue() // Duplication
    )
  }
private:
  Manager* manager;
};
```

----

#### **Stupid** vs <strike>SOLID</strike>

#### Unit-testing?

```cpp
#define private public
```

```cpp
struct ManagerStub {

};
```

```cpp
"should print read value"_test = [] {
  //given
  Logger::instance().disable(); // disable global logger
  App app{};
  auto manager = std::make_unique<FakeManager>();
  app.manager = manager.get();

  //when
  app.run();

  //then
};
```

#### Let's just do Acceptance-testing instead!

----

### A few iterations later...
####(after some SOLID courses)

----

#### <strike>Stupid</strike> vs **SOLID**

```cpp
/**
 * Single Responsibility
 * "A class should have only one reason to change" Uncle Bob
 */
class Reader { public: int read(); };
class Printer { public: void print(int); };
```

```cpp
class App {
public:
  // Dependency Inversion
  App(Reader& reader, Printer& printer, Logger& logger)

  void run() {
    const auto value = reader.read();
    Logger << "run:" << value << '\n';
    printer.print(value); // Law of Demeter
                          // "Only talk to your immediate friends"
  }

private:
  Reader& reader;
  Printer& printer;
  Logger& logger;
};
```

----

TODO test

----

### A few more iterations...
####(and after some MORE SOLID courses)

----

#### <strike>Stupid</strike> vs **SOLID** (Dependency Injection)

```cpp
/**
 * "Depend on abstractions, not on concretions"
 */
class IReader {                     class IPrinter {
public:                             public:
  virtual ~IReader() = default;       virtual ~IPrinter() = default;
  virtual int read() = 0;             virtual void print(int);
};                                  };
```

```cpp
class App {
  IReader& reader;
  IPrinter& printer;
  ILogger& logger;

public:
  /**
   * "Don't call us, we'll call you", Hollywood principle
   */
  App(IReader& reader, IPrinter& printer, ILogger& logger);

  void run() {
    const auto value = reader.read();
    Logger << "run:" << value << '\n';
    printer.print(value);
  }
};
```

----

#### DI - Test

```cpp
"should print read value"_test = [] {
  NiceGMock<ILogger> logger{};      // ignore an uninteresting call
  StrictGMock<IReader> reader{};    // fail on uninteresting call
  StrictGMock<IPrinter> printer{};  // wiring!
  App app{reader, printer, logger}; // wiring!

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

###Composition Root

> Unique location in an application where modules are composed together

#### Usage
```cpp
int main() {
  auto file = std::fstream{"input.txt"};                // wiring!
  auto reader = std::make_unique<FileReader>(file);     // wiring!
  auto& out = std::cout;                                // wiring!
  auto printer = std::make_unique<ConsolePrinter>(out); // wiring!
  auto logger = std::make_unique<Logger>();             // wiring!
  App app{reader, printer, logger};                     // wiring!
  app.run();
}
```

####Simplifies writing integration tests

----

### It works but, all in all, it's a <u>Java</u> approach

* Heap
* Reference/Pointer semantics
* Inheritance
  * "Inheritance Is The Base Class of Evil" Sean Parent
* Dynamic Dispatch
* Performance
  * final keyword and devirtualization - https://godbolt.org/g/e8olYN

----

### C++ ain't java - Zero overhead abstractions, please!

<img src="images/java-vs-c.gif" width="65%" />

#### Templates/Concepts

----

####Concepts

```cpp
template <class T>                  template <class T>
const auto Readable =               const auto Printable =
  CopyConstructible<T> &&             CopyConstructible<T> && 
  CopyAssignable<T> &&                CopyAssignable<T> && 
  Callable<T, int()>($(read));        Callable<T, void(int)>($(print));
```

```cpp
// template<Readable TReader, Printable TPrinter> // Concepts-Lite
template<class TReader, class TPrinter, class TLogger>
class App {
  TReader reader;   static_assert(Readable<TReader>());
  TPrinter printer; static_assert(Printable<TPrinter>());
  TLogger logger;   static_assert(Loggable<TLogger>());

public:
  App(TReader reader, TPrinter printer, TLogger logger);

  void run() {
    printer.print(reader.read());
  }
};
```

----

#### and the test
```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // ignore an uninteresting call
  StrictGMock<Readable> reader{};    // fail on uninteresting call
  StrictGMock<Printable> printer{};  // wiring!
  App app{reader, printer, logger};  // C++17 template argument 
                                     // deduction for class templates

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

#### What about dynamic dispatch (not based on inheritance)?

```cpp
class App {
  any<Readable> reader;   // `virtual Readable` with virtual concepts!
  any<Printable> printer; // `virtual Readable` with virtual concepts!
  any<Loggable> logger;   // `virtual Readable` with virtual concepts!

public:
  App(any<Readable> reader
    , any<Printable> printer
    , any<Loggable> logger)
    : reader(reader), printer(printer), logger(logger)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

----

#### and the test (Same as with concepts!!!)
```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // ignore an uninteresting call
  StrictGMock<Readable> reader{};    // fail on uninteresting call
  StrictGMock<Printable> printer{};  // wiring!
  App app{reader, printer, logger};  // C++17 template argument 
                                     // deduction for class templates

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

### Manual Dependency Injection - Wiring Mess

> Doesn't matter which option will be chosen the wiring will have to happen either way!

```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // WIRING!
  StrictGMock<Readable> reader{};    // WIRING!
  StrictGMock<Printable> printer{};  // WIRING!
  App app{reader, printer, logger};  // WIRING!
  ...
};
```

```cpp
int main() {
  auto file = std::fstream{"input.txt"};                // WIRING!
  auto reader = std::make_unique<FileReader>(file);     // WIRING!
  auto& out = std::cout;                                // WIRING!
  auto printer = std::make_unique<ConsolePrinter>(out); // WIRING!
  auto logger = std::make_unique<Logger>();             // WIRING!
  App app{reader, printer, logger};                     // WIRING!
  ...
}
```

----

### What about Factories?

```cpp
class ReaderFactory {
  static auto create(std::string_view file) {
    return std::make_unique<FileReader>(file);
  }
};
```

##### Test
```cpp
"should create a file reader"_test = [] {
  ReaderFactory factory{};
  auto reader = factory.create("test_file.txt");

  EXPECT(reader.get()); // Is that enough?
  ...
};
```

#### Factories are really hard to test!

----

###Manual DI - Wiring

* ####Single Responsibility Principle
  =>
    * ####A lot of classes
    =>
      * ####Wiring Mess
      =>
        * ####Hard to maintain + Lazy programmers (99%)
        =>
          * ####Hacks/Workarounds (~~Single Responsibility~~)

-----

###Solution

####Simplify/Remove the wiring mess
  ####By Automating dependency injection?
=>
### [[Boost].DI](https://github.com/boost-experimental/di)

----

### `SOLID` references

| | |
|-|-|
| VC | https://github.com/boost-experimental/vc |
| Dyno | https://github.com/ldionne/dyno |
| Virtual Concepts | [Virtual Concepts Proposal](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |

==============================================================================

## Consider using dependency injection framework to avoid the wiring mess and inject mocks automatically

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Hello World

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
template<class TReader = Readable, class TSize = class Size>
class App {                                               ^
 public:                                                  |
  App(const TReader&, std::unique_ptr<IPrinter>, config); |
};           ^                            ^          ^    |
             |                            \-------\  |    |
             \--------------------------------\   |  |    |
int main() {                                  |   |  |    |
  const auto injector = di::make_injector(    |   |  |    |
     di::bind<Readable>.to<FileReader>(),   --/   |  |    |
     di::bind<IPrinter>.to<ConsolePrinter>(), ----/  |    |
     config{"127.0.0.1", 8080}, ---------------------/    |
     di::bind<class Size>.to<int_<42>>() -----------------/
  );
  injector.create<App>().run(); // or di::make<App>(...).run();
}
```

```cpp
// App<FileReader<...>, int_<42>>{
//   FileReader<...>{}, 
//   std::make_unique<ConsolePrinter>(), 
//   config{"127.0.0.1", 8080}
// }.run();
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Automatic Injection

#####Manual DI - Wiring mess

```cpp
int main() {
  auto reader = Reader{};          // WIRING!
  auto printer = Printer{};        // WIRING!
  auto app = App{reader, printer}; // WIRING!
  app.run();
}
```

#####[Boost].DI

```cpp
int main() {
  di::make_injector().create<App>().run();
}
```
  * [Boost].DI will also boost your performance
    * No run-time overhead (wiring at compile time)
    * Cache friendly object layout (whole graph is known at compile time)

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Refactoring for free!

####Let's change `App` constructor

######Before

```cpp
App(Reader& reader, Printer& printer)
  : reader(reader))
  , printer(printer)
{ }
```

######After

```cpp
App(Printer& printer, std::unique_ptr<Reader> reader)
 : printer(printer)
 , reader(std::move(reader))
{}
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Refactoring for free!

#####Manual DI - Wiring mess

```cpp
int main() {
  auto reader = std::make_unique<Reader>{};   // DIFF Wiring!
  auto printer = Printer{};                   // Wiring
  auto app = App{printer, std::move(reader)}; // DIFF Wiring!
  app.run();
}
```

#####[Boost].DI - No changes!

```cpp
int main() {
  di::make_injector().create<App>().run(); // same as before!
}
```

----

### Automatic Mocks Injection

* Write test easily and quickly
* Implantation details, how deps are injected, should not affect the test
* Isolate the word around us

----

####Test - Manual mocks injection

```cpp
"should print read value"_test = [] {
  GMock<Readable> reader{};                       // Boilerplate
  GMock<Printable> printer{};                     // Boilerplate
  App<Readable, Printable> app{reader, printer};  // Boilerplate

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

####Test - Automatic mocks injection
```cpp
"should print read text"_test = [] {
  auto [app, mocks] = testing::make<App>();

  EXPECT_CALL(mocks<Readable)>(), read).WillOnce(Return(42));
  EXPECT_CALL(mocks<Readable>(), print, 42);

  app.run();
};
```

----

### Automatic Mocks Injection - Let's change App

####Test - Manual mocks injection (LOC changed: 5/6, LOC added: 1)

```cpp
"should print read value"_test = [] {
  auto reader = std::make_shared<GMock<Readable>>();        // Boilerplate
  auto printer = std::make_unique<GMock<Printable>>();      // Boilerplate
  auto printer_ptr = printer.get();                         // Boilerplate
  App<Printable, Readable> app{reader, std::move(printer)}; // Boilerplate

  EXPECT_CALL(*reader, read).WillOnce(Return(42)); // NOTICE, dereference
  EXPECT_CALL(printer_ptr, print, 42);             // NOTICE, dereference

  app.run();
};
```

####Test - Automatic mocks injection (LOC changed: 0/6, LOC added: 0)
```cpp
"should print read text"_test = [] {
  auto [app, mocks] = testing::make<App>(); // SAME OLD, SAME OLD!

  EXPECT_CALL(mocks<Readable)>(), read).WillOnce(Return(42));
  EXPECT_CALL(mocks<Readable>(), print, 42);

  app.run();
};
```

----

### But how to produce testable code by default?

### Solution -> Test Driven Development

==============================================================================

## Consider test driving the implementation

| | | |
|-|-|-|
| TDD | Test Driven Development | Unit Tests |
| BDD | Behaviour Test Driven Development | Unit/Integration Tests |

----

##TDD Mantra - Red-Green-Refactor

<img src="images/tdd.gif" width="40%" />

> Refactor => remove duplicates!

----

##The Three Rules Of Tdd

1. You are not allowed to write any production code unless it is to make a failing unit test pass
2. You are not allowed to write any more of a unit test than is sufficient to fail
  * Compilation failures are failures
3. You are not allowed to write any more production code than is sufficient to pass the one failing unit test

----

##Test Driven Development (TDD)

* All benefits of Unit-Testing!

* TDD drives the design by producing
  * Loosely coupled code (no globals/singletons)
  * Easy to test code (no god objects)

* No need for the test coverage <- it implies 100%

----

## Behaviour Driven Development (BDD)

#### Language

```cpp
"[TDD] add numbers"_test = [] { "[BDD} should add 2 numbers" = [] {
  EXPECT_CALL(sum, add(2, 2)).    GIVEN(sum, add(2, 2)).
    WillOnce(Return(4));          WillOnce(Return(4));
  c.add(2, 2);                    WHEN(calc.add(2, 2));
  EXPECT(count == 4);             THEN(count).should_be(4);
};                              };
```


#### Scope
| | Test | Focus |
|-|-|-|
| TDD | Unit Testing | Locked Implementation |
| BDD | Unit/Integration Testing | Locked Behaviour |

----

## BDD (Given/When/Then) - Example

[Gherkin/Cucumber](https://github.com/cucumber/cucumber-cpp)

```cpp
Feature: File Viewer

Scenario 1: Value from a file is displayed
 Given I have a file with a 42 value in it
   And the App is created
 When The App runs
 Then The 42 should be printed
```


```
```

----

### BDD - Gherkin/Cucumber (Integration Testing)

```cpp
GIVEN("^I have a file with a (\\d+) in it$") {
  REGEX_PARAM(int, n);
  ScenarioScope<AppCtx> context{};
  context->app.push(n);
}
```

```cpp
GIVEN("^The App is created$") {
  ScenarioScope<AppCtx> context{};
  std::cout.rdbuf(context->app.buffer.rdbuf()); // redirect cout
  context->app = di::make<App>(production_wiring);
}
```

```cpp
WHEN("^The App runs") {
  ScenarioScope<AppCtx> context{};
  context->app.run();
}
```

```cpp
THEN("^The (\\d+) should be printed") {
  REGEX_PARAM(int, expected);
  ScenarioScope<AppCtx> context{};
  specify(context->buffer, should.equal(expected));
}
```

----

## BDD - DI/Mocking (Unit Testing)

```cpp
"[scenario] Value from a file is displayed"_test {
  GIVEN("Hhe App is created") {
    auto [app, mocks] = testing::make<App>()
  }
  GIVEN(mocks<Readable>(), read().WillOnce(Return(42));

  WHEN(app.run());

  THEN(mocks<Printable>(), print(42));
}
```

----

## Behaviour Driven Development

* Complemenary with TDD! 
* Focus on customer needs (behaviours)

==============================================================================

## Showcase (User Story -> ... -> Commit)

----

## Tools

* Agile (Scrum)
* UML 2.5 (design)
* eXtreme Programming
* Continous Integration
* BDD/TDD

----

## Product backlog refinment

#### Story / Priority
> #### As an user of the trading system I would like to trade stocks

----

### Product backlog refinment - Acceptance critera (BDD)

```
Feature: Automatic Trading System
```

```
Scenario 1: Trading System requests to buy shares
  Given The Trading System is up and running
    And The TS has at least $100'000 to buy shares

  When at least 1000 shares of GOOGL were bought at price $950

  Then A buy order for 100 shares of GOOGL should be executed
   And The TS should own 100 shares of GOOGL
   And The TS should have $90'000
```

```
Scenario 2: Trading System requests to sell shares
  Given The Trading System is up and running
    And The TS owns 100 shares of APPL stock

  When 50 shares of MSFT were sold 

  Then A sell order for 50 shares of MSFT stock should have been executed
   And The TS should own 50 shares of APPL stock
```

```
Scenario 3: ...
Scenario 4: ...
...
```

----

### If we use Cucumber we already have our BDD tests!

----

## Design/Workshop

#### Domains/Components
![design](images/design.png)

----

## Design/Workshop

#### Activities
![ad](images/ad.png)

----

## Stories/Tasks - Cross functional

![ad](images/ad_tasks.png)

#### Tasks
  1. [1.0]  (delivrable!)
  1. [1.1]  (delivrable!)

----

## Planning

#### Estimetes (Common SP definition required)
  * [1.0]  (5SP)
  * [1.1]  (8SP)

  * Team velocity (avg. 15 SP)
  * Commitment ->  [1.0] and [1/1]

----

## Sprint

| | | |
|-|-|-|
| TODO | WIP | DONE |
|  | [1.0] | |
| [1.1] | | |

----

TDD
eXtreme programming -> pairing, one test one implementation

> Always start from the expections (express intentions!)
----


#### 1. TDD/RED - Write a bit of test (start from expectations, intentions)

```cpp
"should not print anything when the input is empty" = [] {
  app.run();
  EXPECT("" == out.str());
};
```

----
#### 2. TDD/GREEN - Make it compile/pass (the simpler way)
#### 3. TDD/REFECTOR - Remove duplicates/extract

----

```cpp
template<class TStream>
struct exchange {
  void receive();
  void send();
};

struct shares {
  int get(std::string_view share);
};

template<class TShares>
struct decision_maker {
  std::pair<bool, what> should_by();
  void update(T);
};

template<class TDecisionMaker, class TExchange, class Translactor>
struct trading_system {
  TDecisionMaker& dm;
  TExchange& exchange;

  void process() {
    if (auto buffer = exchange.receive(); buffer > 0) {
      dm.update(translator.translate(buffer));
    } eles if (auto [fire, what] = dm.should_buy(); fire) {
      exchange.send(translator.translate(what));
    }
  }
};

"User request a sell before close of trading"_test = [] {

  auto [ts, mocks] = testing::make<trading_system>(); // creates sut and mocks

  GIVEN(mocks<DecisionMaker>(), should_buy()).WillOnce(Return({true, {"APPL", 20}}));
  GIVEN(mocks("MyShares"_s), get("APPL")).WillOnce(Return(100));

  WHEN(ts.process());

  THEN(mocks("exchange"_s), send({"APPL", 20}));
};


"User request a sell before close of trading"_test = [] {
  testing::mocks mocks{};
  const auto injector = di::make_injector(
    di::bind<Stremable>.to(mocks) [di::override]
  );
  auto ts = injector.create<trading_system>();

  "my first"_scenario = [&] {
    GIVEN(mocks<DecisionMaker>(), should_buy()).WillOnce(Return({true, {"APPL", 20}}));
    GIVEN(mocks("MyShares"_s), get("APPL")).WillOnce(Return(100));

    WHEN(ts.process());

    THEN(mocks("exchange"_s), send({"APPL", 20}));
  }

  "second"_scenario = [&] {
    GIVEN(mocks<DecisionMaker>(), should_buy()).WillOnce(Return({true, {"APPL", 20}}));
    GIVEN(mocks("MyShares"_s), get("APPL")).WillOnce(Return(100));

    WHEN(ts.process());

    THEN(mocks("exchange"_s), send({"APPL", 20}));
  }
};
```

----

#### Commit

      * rebase or merge or branch with history how tthe test eveolved

      [Story.1] Add
      
      Problem:
        - fdsalfdlsa

      Solution:
        - fdsalfjdsalfjdlsaj

    Commit content: acceptance test + unit tests + cross functional

----

#### Code Review/Merge Requeest

    Create a merge request
      github

    Code review
      Did you consider...?

    Someone else is accepting your merge requests

----

  Take the next story... 
    * Pair with someone else of the team!

==============================================================================

## C++2X...

----

### Automatic test registration and std::testing assertions

```cpp
"should add 2 numbers"_test = [] {
  std::testing::assert(4 == add(2, 2));
};
```

----

### Test Suites/Fixtures

```cpp
"Calculator"_test_fixture = [] {
  // set-up
  auto sut = calcualtor{};

  "should add 2 numbers"_test = [&] {
    std::testing::assert(4 == sut.add(2, 2));
  };

  "should sub 2 numbers"_test = [&] {
    std::testing::assert(0 == sut.sub(2, 2));
  };

  // tear-down
};
```

----

### Proposals

| | |
|-|-|
| Mocks Generation | [(SG7) Static reflection](www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf) |
| Type constraints | [(SG8) Concepts lite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf) |
| Concepts based type erasure | [Virtual Concepts](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |

==============================================================================

## Summary

----

### Good practises are good practices for a reason!

* Consider using a good* testing framework
* Consider using a good* Mocking framework
* Consider writing `SOLID` instead of `STUPID` code
* Consider using dependency injection framework
* Consider test driving the implementation

----

###Last but not least...

----

### "If you liked it then you should have put a test on it" Beyonce rule

==============================================================================

## Questions?

| | |
|-|-|
| GUnit     | https://github.com/cpp-testing/GUnit |
| VC        | https://github.com/boost-experimental/vc |
|[Boost].DI | https://github.com/boost-experimental/di |

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
