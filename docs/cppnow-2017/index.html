<!doctype html>

<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Towards Painless Testing</title>

		<meta name="description" content="Towards Painless Testing">
		<meta name="author" content="Kris Jusiak">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">

            <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">
#### C++ Now 2017
# Towards Painless Testing

Kris Jusiak, Quantlab Financial

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

==============================================================================

## "The only way to go fast is to go well" Uncle Bob

==============================================================================

## Agenda

* Testing
  * Why?
  * How And When?
    * Frameworks
    * Mocking
    * Writing A Testable Code (Unit Testing)
        * Single Responsibility Principle
        * Dependency Injection
    * Automatic Mocks Injection
    * Acceptance Testing
* Showcase (User Story -> ... -> Commit)
* C++2X...

==============================================================================

##Why testing is important?

![testing](images/cowboy.png)

----

##It's all about Money!

![cost](images/cost.jpg)

----

##Different types of tests have different costs

![pyramid](images/pyramid.png)

----

* Unit-Tests - 70-85% 
  * Testing in isolation (mocking)
  * Easy to write
  * Quick to run (immediate feedback)
  * Find code issues quickly 
  * Test corner cases
  * Documentation (requirements)
  * Refactoring without worries

* Integration-Tests - 10-20% (between classes)
  * Integration between classes

* Acceptance-Tests - 5-10%
  * Slower to run
  * Harder to write
  * In some cases might be manual

----

##Test your code and save more money!

![cost_testing](images/cost_testing.jpg)

----

### "Don't cling to a mistake just because you spent a lot of time and money making it!"

==============================================================================

### Testing - Goals

| | |
|-|-|
| Simplicity | Testing can't be hard  |
| Expressiveness | Tests should not have logic |
| Reusability | Implementation details should not trigger tests changes |
| Quality | Test code should be treated as production code |

> To achieve those goals...

==============================================================================

## Consider using a good* testing framework

####good*
* Easy to add and run new tests (automatic test registration)
* Proper assertions system
* Feature reach (test suites/fixtures/different outputs)

----

### Testing in C++ without a framework

```cpp
#include <cassert> // no much testing facilities in the standard

void test_should_add_2_numbers() {
  assert(4 == add(2, 2)); // *no proper asserts
                          // *no nice outputs
}

int main() {
  test_should_add_2_numbers(); // *no automatic test registration
}
```

```sh
$CXX -g tests.cpp && ./a.out # *no way to specify which tests to run
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">Boost.Test</p>

```cpp
BOOST_AUTO_TEST_CASE(should_add_2_numbers) {
  BOOST_CHECK_EQUAL(4, add(2, 2));
}
```

#### <p align="left">Catch</p>

```cpp
TEST_CASE("Numbers can be added", "[add]") {
  SECTION("should add 2 numbers") { REQUIRE(4 == add(2, 2)); }
}
```

----

### Solution -> C++ Testing Frameworks

#### <p align="left">GoogleTest</p>

```cpp
TEST(AddTest, should_add_2_numbers) {
  EXPECT_EQ(4, add(2, 2));
}
```

#### <p align="left">GoogleTest/GUnit.GTest</p>

```cpp
GTEST("Can add numbers") {
  SHOULD("add 2 numbers") { EXPECT_EQ(4, add(2, 2)); }
}
```

#### <p align="left">GUnit.GTest-Lite (it will be used on the slides)</p>
```cpp
"should add 2 numbers"_test = [] {
  EXPECT(4 == add(2, 2));
};
```

----

### Testing-Frameworks references

| | |
|-|-|
| GUnit.GTest | https://github.com/cpp-testing/GUnit#GTest |
| GUnit.GTest-Lite | https://github.com/cpp-testing/GUnit#GTest-Lite |

==============================================================================

## Consider using a good* Mocking framework

####good*
* Easy to do to simple things but with possibility to do more complex too
* Limited boilerplate (especially macros)
* Mocking Interfaces/Concepts/Type-Erasure

----

### Stubs vs Fakes vs Mocks

| | |
|-|-|
|Fake|An object with limited capabilities|
|Stubs|An object that provides predefined answers to method calls and record calls|
|Mocks|An object on which you set expectations which are verified by the mock|

---

https://martinfowler.com/articles/mocksArentStubs.html

----

###Mocking interfaces - the story so far - GoogleMock

```cpp
class IReader {
public:
  virtual ~interface() = default;
  virtual int read() const;
};
```

```cpp
/**
 * Boilerplate
 */
class MockReader : public IReader {
public:
  MOCK_CONST_METHOD1(read, int()); // See the bug?
};
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  EXPECT_CALL(reader, read()).WillOnce(Return(42));
  EXPECT(42 == reader.read(42));
};
```

----

###Mocking interfaces - better alternatives

* HippoMocks
* FakeIt
* **GUnit.GMock** (based on GoogleMock)

```cpp
"should read 42"_test = [] {
  GMock<IReader> reader{};
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

* No hand written macros :)
* No boilerplate code
* Not a standard solution either!
  * vtable manipulation involved

----

### Mocking templates

#### We are back to square one <- macros

```cpp
template<class TReader>
auto read(TReader& reader) { return reader.read(); }
```

```cpp
class MockReader : public IReader {
public:
  MOCK_CONST_METHOD1(read, int()); // See the bug?
};
```

```cpp
"should read 42"_test = [] {
  MockReader reader{};
  // At least we can use the same front-end
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  read(reader);
  EXPECT(42 == reader.read);
};
```

----

### Mocking concepts

#### Concepts lite - not yet :(

```cpp
template <class T>
concept bool Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  requires(T t) {
    { t.read() -> int }
  }
};
```

#### But with concept emulation (C++14) - yes!

```cpp
template <class T>
const auto Readable =
  CopyConstructible<T> &&
  CopyAssignable<T> &&
  Callable<T, int()>($(read));
```

----

### Mocking concepts

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

## TODO explain how!

----

### Mocking type-erasure

##### Type Erasure (dynamic dispatch without inheritance)
```cpp
any<Readable> reader = FileReader{"file.txt"};
reader = StreamReader{};
```

```cpp
auto read(any<Readable> reader) {
  return reader.read();
}
```

```cpp
"should read 42"_test = [] {
  GMock<Readable> reader{}; // concept based
                            // the same as with concepts!
  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT(42 == reader.read());
};
```

----

### Mocking references

| | |
|-|-|
| GoogleMock | https://github.com/google/googletest |
| GUnit.GMock | https://github.com/cpp-testing/GUnit#GMock |
| Dyno (Type-Erasure) | https://github.com/ldionne/dyno |

==============================================================================

### Consider writing `SOLID` instead of `STUPID` code

<table><tr>
 <td>
  <table>
    <tr><td><b>S</b></td><td><u>Single Responsibility</u></td></tr>
    <tr><td><b>O</b></td><td>Open-close</td></tr>
    <tr><td><b>L</b></td><td>Liskov substitution</td></tr>
    <tr><td><b>I</b></td><td>Interface segregation</td></tr>
    <tr><td><b>D</b></td><td><u>Dependency inversion</u></td></tr>
  </table>
 </td>

 <td>
  <table>
    <tr><td><b>S</b></td><td><strike>Singleton</strike></td></tr>
    <tr><td><b>T</b></td><td><strike>Tight Coupling</strike></td></tr>
    <tr><td><b>U</b></td><td><strike>Untestability</strike></td></tr>
    <tr><td><b>P</b></td><td><strike>Premature Optimization</strike></td></tr>
    <tr><td><b>I</b></td><td><strike>Indescriptive Naming</strike></td></tr>
    <tr><td><b>D</b></td><td><strike>Duplication</strike></td></tr>
  </table>
 </td>

 </tr>
</table>
> "Clean Code" Uncle Bob

----

### Story: Print a value from a file

```
Scenario 1: Value from a file is displayed
 Given an 'input.txt' file with an integer value in it
   And console terminal is ready
 When the App runs
 Then the integer value from 'input.txt' file
   should be printed on the terminal console
```

----

### KISS - ~~Keep it simple~~, STUPID

```cpp
int main() {
  auto value = 0;
  {
    std::ifstream file{"input.txt"};
    assert(file.good());
    file >> value;
  }
  std::cout << value << '\n';
}
```

Unit-Testing - **Give me a break!**

----

### A few iterations later...

----

#### **Stupid** vs <strike>SOLID</strike>

```cpp
class Manager { // Indescriptive Naming
public:
  Updater& getUpdater(); // Untestability
  Reader& getReader();   // Untestability
  Writer& getWriter();   // Untestability
  Creator& getCreator(); // Untestability
  void update(float);
};
```

```cpp
class App {
public:
  App() { manager = new Manager; } // Tight Coupling
  ~App() { delete manager; }

  __attribute__((always_inline)) void run() { // Premature Optimization
    Logger::instance() // Singleton
      << "run:" << manager.getReader().get()->getValue() << '\n';

    manager.getWriter().getOutputter()->print(
      manager.getReader().get()->getValue() // Duplication
    )
  }
private:
  Manager* manager;
};
```

----

#### **Stupid** vs <strike>SOLID</strike>

#### Unit-testing?

```cpp
#define private public
```

```cpp
struct ManagerStub {

};
```

```cpp
"should print read value"_test = [] {
  //given
  Logger::instance().disable(); // disable global logger
  App app{};
  auto manager = std::make_unique<FakeManager>();
  app.manager = manager.get();

  //when
  app.run();

  //then
};
```

#### Let's just do Acceptance-testing instead!

----

### A few iterations later...
####(after some SOLID courses)

----

#### <strike>Stupid</strike> vs **SOLID**

```cpp
/**
 * Single Responsibility
 * "A class should have only one reason to change" Uncle Bob
 */
class Reader { public: int read(); };
class Printer { public: void print(int); };
```

```cpp
class App {
public:
  // Dependency Inversion
  App(Reader& reader, Printer& printer, Logger& logger)

  void run() {
    const auto value = reader.read();
    Logger << "run:" << value << '\n';
    printer.print(value); // Law of Demeter
                          // "Only talk to your immediate friends"
  }

private:
  Reader& reader;
  Printer& printer;
  Logger& logger;
};
```

----

TODO test

----

### A few more iterations...
####(and after some MORE SOLID courses)

----

#### <strike>Stupid</strike> vs **SOLID** (Dependency Injection)

```cpp
/**
 * "Depend on abstractions, not on concretions"
 */
class IReader {                     class IPrinter {
public:                             public:
  virtual ~IReader() = default;       virtual ~IPrinter() = default;
  virtual int read() = 0;             virtual void print(int);
};                                  };
```

```cpp
class App {
  IReader& reader;
  IPrinter& printer;
  ILogger& logger;

public:
  /**
   * "Don't call us, we'll call you", Hollywood principle
   */
  App(IReader& reader, IPrinter& printer, ILogger& logger);

  void run() {
    const auto value = reader.read();
    Logger << "run:" << value << '\n';
    printer.print(value);
  }
};
```

----

#### DI - Test

```cpp
"should print read value"_test = [] {
  NiceGMock<ILogger> logger{};      // ignore an uninteresting call
  StrictGMock<IReader> reader{};    // fail on uninteresting call
  StrictGMock<IPrinter> printer{};  // wiring!
  App app{reader, printer, logger}; // wiring!

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

###Composition Root

> Unique location in an application where modules are composed together

#### Usage
```cpp
int main() {
  auto file = std::fstream{"input.txt"};                // wiring!
  auto reader = std::make_unique<FileReader>(file);     // wiring!
  auto& out = std::cout;                                // wiring!
  auto printer = std::make_unique<ConsolePrinter>(out); // wiring!
  auto logger = std::make_unique<Logger>();             // wiring!
  App app{reader, printer, logger};                     // wiring!
  app.run();
}
```

####Simplifies writing integration tests

----

### It works but, all in all, it's a <u>Java</u> approach

* Heap
* Reference/Pointer semantics
* Inheritance
  * "Inheritance Is The Base Class of Evil" Sean Parent
* Dynamic Dispatch
* Performance
  * final keyword and devirtualization - https://godbolt.org/g/e8olYN

----

### Give me templates/concepts!

<img src="images/java-vs-c.gif" width="65%" />

----

####Concepts

```cpp
template <class T>                  template <class T>
const auto Readable =               const auto Printable =
  CopyConstructible<T> &&             CopyConstructible<T> && 
  CopyAssignable<T> &&                CopyAssignable<T> && 
  Callable<T, int()>($(read));        Callable<T, void(int)>($(print));
```

```cpp
// template<Readable TReader, Printable TPrinter> // Concepts-Lite
template<class TReader, class TPrinter, class TLogger>
class App {
  TReader reader;   static_assert(Readable<TReader>());
  TPrinter printer; static_assert(Printable<TPrinter>());
  TLogger logger;   static_assert(Loggable<TLogger>());

public:
  App(TReader reader, TPrinter printer, TLogger logger);

  void run() {
    printer.print(reader.read());
  }
};
```

----

#### and the test
```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // ignore an uninteresting call
  StrictGMock<Readable> reader{};    // fail on uninteresting call
  StrictGMock<Printable> printer{};  // wiring!
  App app{reader, printer, logger};  // C++17 template argument 
                                     // deduction for class templates

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

#### What about dynamic dispatch (not based on inheritance)?

```cpp
class App {
  any<Readable> reader;   // `virtual Readable` with virtual concepts!
  any<Printable> printer; // `virtual Readable` with virtual concepts!
  any<Loggable> logger;   // `virtual Readable` with virtual concepts!

public:
  App(any<Readable> reader, any<Printable> printer, any<Loggable> logger)
    : reader(reader), printer(printer)
  { }

  void run() {
    printer.print(reader.read());
  }
};
```

----

#### and the test (Same as with concepts!!!)
```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // ignore an uninteresting call
  StrictGMock<Readable> reader{};    // fail on uninteresting call
  StrictGMock<Printable> printer{};  // wiring!
  App app{reader, printer, logger};  // C++17 template argument 
                                     // deduction for class templates

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

----

### Manual Dependency Injection - Wiring Mess

> Doesn't matter which option will be chosen the wiring will have to happen either way!

```cpp
"should print read value"_test = [] {
  NiceGMock<Loggable> logger{};      // WIRING!
  StrictGMock<Readable> reader{};    // WIRING!
  StrictGMock<Printable> printer{};  // WIRING!
  App app{reader, printer, logger};  // WIRING!
  ...
};
```

```cpp
int main() {
  auto file = std::fstream{"input.txt"};                // WIRING!
  auto reader = std::make_unique<FileReader>(file);     // WIRING!
  auto& out = std::cout;                                // WIRING!
  auto printer = std::make_unique<ConsolePrinter>(out); // WIRING!
  auto logger = std::make_unique<Logger>();             // WIRING!
  App app{reader, printer, logger};                     // WIRING!
  ...
}
```

----

###Manual DI - Wiring

* ####Single Responsibility Principle
  =>
    * ####A lot of classes
    =>
      * ####Wiring Mess
      =>
        * ####Hard to maintain + Lazy programmers (99%)
        =>
          * ####Hacks/Workarounds (~~Single Responsibility~~)

-----

###Solution

####Simplify/Remove the wiring mess
  ####By Automating dependency injection?
=>
### [[Boost].DI](https://github.com/boost-experimental/di)

----

### `SOLID` references

| | |
|-|-|
| VC | https://github.com/boost-experimental/vc |
| Dyno | https://github.com/ldionne/dyno |
| Virtual Concepts | [Virtual Concepts Proposal](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |

==============================================================================

## Consider using dependency injection framework to avoid the wiring mess and inject mocks automatically

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Hello World

```cpp
#include <boost/di.hpp>
namespace di = boost::di;
```

```cpp
template<class TReader = Readable>
class App {
 public:
  App(TReader&, const IPrinter&); // DI handles
};        ^                 ^     // order and types
          |                 \-------------------------\
          \---------------------------------------\   |
int main() {                                      |   |
  const auto injector = di::make_injector(        |   |
     di::bind<Readable>.to<FileReader>(),   ------/   |
     di::bind<IPrinter>.to<ConsolePrinter>() ---------/
  );

  injector.create<App>().run();
}
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Automatic Injection

#####Manual DI - Wiring mess

```cpp
int main() {
  auto reader = Reader{};          // WIRING!
  auto printer = Printer{};        // WIRING!
  auto app = App{reader, printer}; // WIRING!
  app.run();
}
```

#####[Boost].DI

```cpp
int main() {
  di::make_injector().create<App>().run();
}
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Refactoring for free!

####Let's change `App` constructor

######Before

```cpp
App(Reader& reader, Printer& printer)
  : reader(reader))
  , printer(printer)
{ }
```

######After

```cpp
App(Printer& printer, std::unique_ptr<Reader> reader)
 : printer(printer)
 , reader(std::move(reader))
{}
```

----

###[[Boost].DI](https://github.com/boost-experimental/di) - Refactoring for free!

#####Manual DI - Wiring mess

```cpp
int main() {
  auto reader = std::make_unique<Reader>{};   // DIFF Wiring!
  auto printer = Printer{};                   // Wiring
  auto app = App{printer, std::move(reader)}; // DIFF Wiring!
  app.run();
}
```

#####[Boost].DI - No changes!

```cpp
int main() {
  di::make_injector().create<App>().run(); // same as before!
}
```

----

### Automatic Mocks Injection

* Write test easily and quickly
* Implantation details, how deps are injected, should not affect the test
* Isolate the word around us

----

####Test - Manual mocks injection

```cpp
"should print read value"_test = [] {
  GMock<Readable> reader{};                       // Boilerplate
  GMock<Printable> printer{};                     // Boilerplate
  App<Readable, Printable> app{reader, printer};  // Boilerplate

  EXPECT_CALL(reader, read).WillOnce(Return(42));
  EXPECT_CALL(printer, print, 42);

  app.run();
};
```

####Test - Automatic mocks injection
```cpp
"should print read text"_test = [] {
  auto [app, mocks] = testing::make<App>();

  EXPECT_CALL(mocks<Readable)>(), read).WillOnce(Return(42));
  EXPECT_CALL(mocks<Readable>(), print, 42);

  app.run();
};
```

----

### Automatic Mocks Injection - Let's change App

####Test - Manual mocks injection (LOC changed: 5/6, LOC added: 1)

```cpp
"should print read value"_test = [] {
  auto reader = std::make_shared<GMock<Readable>>();        // Boilerplate
  auto printer = std::make_unique<GMock<Printable>>();      // Boilerplate
  auto printer_ptr = printer.get();                         // Boilerplate
  App<Printable, Readable> app{reader, std::move(printer)}; // Boilerplate

  EXPECT_CALL(*reader, read).WillOnce(Return(42)); // NOTICE, dereference
  EXPECT_CALL(printer_ptr, print, 42);             // NOTICE, dereference

  app.run();
};
```

####Test - Automatic mocks injection (LOC changed: 0/6, LOC added: 0)
```cpp
"should print read text"_test = [] {
  auto [app, mocks] = testing::make<App>(); // SAME OLD, SAME OLD!

  EXPECT_CALL(mocks<Readable)>(), read).WillOnce(Return(42));
  EXPECT_CALL(mocks<Readable>(), print, 42);

  app.run();
};
```

----

### But how to produce testable code by default?

### Solution -> Test Driven Development

==============================================================================

## Consider test driving implementation

| | | |
|-|-|-|
| TDD | Test Driven Development | Unit Tests |
| ATDD | Acceptance Test Driven Development | Acceptance Tests |

----

##TDD Mantra - Red-Green-Refactor

<img src="images/tdd.gif" width="40%" />

> Refactor => remove duplicates!

----

##The Three Rules Of Tdd

1. You are not allowed to write any production code unless it is to make a failing unit test pass
2. You are not allowed to write any more of a unit test than is sufficient to fail
  * Compilation failures are failures
3. You are not allowed to write any more production code than is sufficient to pass the one failing unit test

----

##Let's start all over again with TDD

----

#### 1. TDD/RED - Write a bit of test (start from expectations, intentions)

```cpp
"should not print anything when the input is empty" = [] {
  app.run();
  EXPECT("" == out.str());
};
```

----

#### 2. TDD/GREEN - Make it compile/pass (the simpler way)

```cpp
"should not print anythinig when the input is empty" = [] {
  std::stringstream out{};
  struct {
    void run() { }
    std::ostream& os;
  } app{out};
  app.run();
  EXPECT("" == out.str());
};
```

----

#### 3. TDD/REFECTOR - Remove duplicates/extract

```cpp
class App {
public:
  explicit App(std::ostream& os)
    : os(os)
  { }

  void run() { }

private:
  std::ostream& os;
};
```

```cpp
"should not print anythinig when the input is empty" = [] {
  // given (arrange)
  std::stringstream out{};
  App app{};

  // when (act)
  app.run();

  // then (assert)
  EXPECT("" == out.str());
};
```

----

#### 1. TDD/RED - Write a bit of the next test

```cpp
"should print value 42 when the input is 42" = [] {
  // given
  std::stringstream out{};
  std::stringstream in{};

  // when
  app.run();

  // then
  EXPECT("42" == out.str());
};
```

----

#### 2. TDD/GREEN - Make it compile/pass (the simpler way)

```cpp
"should print value 42 when the input is 42" = [] {
  // given
  std::stringstream in{}, out{};
  struct { 
    void run() { out << "42"; }
    std::ostream& out;
    std::istream& in;
  } app{in, out};
  
  // when
  app.run();
  
  // then
  EXPECT("42" == out.str());
};
```

----

#### 3. TDD/REFECTOR - remove duplicates (across all tests)

```cpp
"should not print anythinig when the input is empty" = [] {
  // given (arrange)
  std::stringstream in{}, out{};
  App app{in, out};

  // when (act)
  app.run();

  // then (assert)
  EXPECT("" == out.str());
};
```

```cpp
"should print value 42 when the input is 42" = [] {
  // given (arrange)
  const auto value = "42";
  std::stringstream in, out{};
  App app{in, out};
  in << value;

  // when (act)
  app.run();

  // then (assert)
  EXPECT(value == out.str());
};
```

----

#### 3. TDD/REFECTOR - remove duplicates (across the implementation)

```cpp
class App {
public:
  App(std::istream& in, std::oustream& out)
    : in(in), out(out)
  { }

  void run() { out << in.rdbuf(); }

private:
  std::istream& in;
  std::ostream& out;
};
```

----

##Test Driven Development (TDD)

* All benefits of Unit-Testing!

* TDD drives the design by producing
  * Loosely coupled code
  * Easy to test code

* No need for the test coverage <- it implies 100%

* How to know that code wasn't written in TDD?
  * You comment some code and there is no failing test
  * Singletons/Globals in the code (the root of all evil)
  * God objects
  * ...

----

#### Acceptance Test Driven Development (ATDD)

```
Scenario 1: Value from a file is displayed
 Given an 'input.txt' file with an integer value in it
   And console terminal is ready
 When the App runs
 Then the integer value from 'input.txt'
   should be printed on the terminal console
```

 ```cpp
GTEST(example) {
  namespace di = boost::di;

  SHOULD("create example") {
    const auto injector = di::make_injector(
      di::bind<interface>.to(di::NiceGMock{mocks})
    , di::bind<interface2>.to(di::StrictGMock{mocks})
    );

    sut = testing::make<SUT>(injector);

    EXPECT_CALL(mock<interface>(), (get)(_)).WillOnce(Return(123));
    EXPECT_CALL(mock<interface2>(), (f2)(123));

    sut->update();
  }
}
```

==============================================================================

## Showcase (User Story -> ... -> Commit)

----

* Agile (Scrum Methodology)
* UML 2.5 (design)
* eXtreme Programming Techniques
* Continous Integration (github/travis)
* ATDD/BDD/TDD
* C++17

> All code compiles and pass tests.

----

1. Product backlog refinment

Refinment
  Priority: 
    Story:  As a trading system I would like to send orders to the exchange

  Acceptance critera
    ...

----

Design/Workshop

    Domains
      decision engine <-> gateway <-> exchange

    Cross functional:

           decision engine
          /
         trigger order
         /
        has any oustanding orders
    yes / \ no
     X    gateway
            \ send order
        
           exchange
          /
         confirmation
         /
      gateway
      / send
    decision engine

----

Tasks
  1. decision... -> yes
  2. decision... -> no
  3. confirmation -> transfer

----

Planning
  Estimates (poker, has to be understood by everyone)
    * story points <- complexity of the task
      1 sp -> transfer a message trhough all layers

    1. decision... -> yes (2sp)
    2. decision... -> no (1sp)
    3. confirmation -> transfer (3sp)

 team velociy (avg. 20 sp)
 commitment -> 1/2/3

----

Sprint (1 week)

  Story 1.
    1.1 Acceptance driven development (ATDD with BDD)

      given

      when

      then

      > start from your expectatoins

    Test Driven Development (unit testing)

      TDD mantra
      TDD real values

      should...

      eXtreme programming -> pairing, one test one implementation


      write a bit more of test

    Commit each time 

      * rebase or merge or branch with history how tthe test eveolved

      [Story.1] Add
      
      Problem:
        - fdsalfdlsa

      Solution:
        - fdsalfjdsalfjdlsaj

    Commit content: acceptance test + unit tests + cross functional

    Create a merge request
      github

    Code review
      Did you consider...?


    Someone else is accepting your merge requests

    Take the next story... 
      * Pair with someone else of the team!

As a I would like to 

Artifacts
  * Acceptance criteria (BDD style)

  Scenario 1: Value from a file is displayed
   Given an 'input.txt' file with an integer value in it
     And console terminal is ready
   When the App runs
   Then the integer value from 'input.txt'
     should be printed on the terminal console

  Scenario 1: Value from a file is displayed
   Given an 'input.txt' file with an integer value in it
     And console terminal is ready
   When the App runs
   Then the integer value from 'input.txt'
     should be printed on the terminal console


     NOTE
> Always start from the expections (express intentions!)
Treat code as production code!
* refactor (remove duplicates)


Example (Print read text app)
1. User story
2. Scenarios (BDD style)
3. Design
    o
   / \
  o   o cross-functional tasks
     /
    o

4. Acceptance driven (per task)
 iteration
  * a bit of BDD test
  * a bit of TDD
  * a bit of implementation

Note: eXtreme programming techniques
* pair programming
  * one dev is writing a test, another one is implementing it

5. Commit (cross functional - AT, UT, impl)
6. Merge request / review

goto 4.

==============================================================================

## C++2X...

----

### Automatic test registration and std::testing assertions

```cpp
"should add 2 numbers"_test = [] {
  std::testing::assert(4 == add(2, 2));
};
```

----

### Test Suites/Fixtures

```cpp
"Calculator"_test_fixture = [] {
  // set-up
  auto sut = calcualtor{};

  "should add 2 numbers"_test = [&] {
    std::testing::assert(4 == sut.add(2, 2));
  };

  "should sub 2 numbers"_test = [&] {
    std::testing::assert(0 == sut.sub(2, 2));
  };

  // tear-down
};
```

----

# References

| | | |
|-|-|-|
| | | |
[(SG8) Concepts lite](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf) |
[Virtual Concepts](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf) |
[(SG7) Static reflection](www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf)

### STD 
* concepts lite
* virtual concepts
* static reflection
* source line info

==============================================================================

## Summary

----

### Good practises are good practices for a reason!

----

### TODO put all consider...

----

###Last but not least...

----

### "If you liked it then you should have put a test on it" Beyonce rule

==============================================================================

## Questions?

| | |
|-|-|
| GUnit     | https://github.com/cpp-testing/GUnit |
| VC        | https://github.com/boost-experimental/vc |
|[Boost].DI | https://github.com/boost-experimental/di |

---

[kris@jusiak.net](mailto:kris@jusiak.net) | [@krisjusiak](https://twitter.com/krisjusiak) | [linkedin.com/in/kris-jusiak](https://www.linkedin.com/in/kris-jusiak)

					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
